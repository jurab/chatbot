<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>search ui prototype</title>

    <!-- font setup -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />

    <style>
      /* global theme tokens */
      :root {
        --bg: #0f1115;
        --card: #1a1d24;
        --muted: #818596;
        --text: #e5e7ef;
        --accent: #6ea1ff;
        --ring: 0 0 0 4px rgba(110, 161, 255, 0.25);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          sans-serif;
        color: var(--text);
        background: var(--bg);
        display: grid;
        place-items: center;
      }

      /* main layout wrapper */
      .wrap {
        width: min(920px, 92vw);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      /* messages area (scrolling chat log) */
      .messages {
        max-height: 60vh;
        overflow-y: auto;
        padding-right: 4px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      /* base chat bubble */
      .message {
        max-width: 70%;
        padding: 8px 12px;
        border-radius: 16px;
        font-size: 14px;
        line-height: 1.4;
        word-wrap: break-word;
        white-space: pre-wrap;
      }

      /* outgoing (user) bubble */
      .message.user {
        margin-left: auto;
        background: var(--accent);
        color: #05060a;
        border-bottom-right-radius: 4px;
      }

      /* incoming (assistant/system) bubble */
      .message.assistant {
        margin-right: auto;
        background: var(--card);
        border-bottom-left-radius: 4px;
      }

      .message.system {
        margin-right: auto;
        background: transparent;
        color: var(--muted);
        font-style: italic;
      }

      /* placeholder bubble while we wait for first tokens */
      .message.assistant.pending {
        color: var(--muted);
        font-style: italic;
        animation: awaitingPulse 1.2s ease-in-out infinite;
      }

      /* subtle animation for "awaiting openai..." text */
      @keyframes awaitingPulse {
        0% {
          opacity: 0.4;
          letter-spacing: 0px;
        }
        50% {
          opacity: 1;
          letter-spacing: 0.5px;
        }
        100% {
          opacity: 0.4;
          letter-spacing: 0px;
        }
      }

      /* input row container (the "search bar" look) */
      .search {
        position: relative;
        background: #242834;
        border-radius: 999px;
        display: flex;
        align-items: center;
        padding: 14px;
        gap: 10px;
        box-shadow:
          0 10px 30px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.03);
      }

      /* plain text input for messages */
      .input {
        flex: 1;
        background: transparent;
        border: none;
        outline: none;
        font-size: 18px;
        color: var(--text);
      }

      .input::placeholder {
        color: #a0a3ad;
      }

      /* "send" button on the right side of the input row */
      .send-btn {
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, #ffffff1a, #ffffff05);
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: none;
        outline: none;
        color: var(--text);
        cursor: pointer;
        box-shadow:
          0 6px 16px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.06);
        transition:
          transform 0.06s ease,
          box-shadow 0.06s ease,
          background 0.2s ease;
        position: relative;
      }

      .send-btn:hover {
        transform: translateY(-1px);
      }

      .send-btn:active {
        transform: translateY(0);
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);
      }

      .send-btn:focus-visible {
        box-shadow: var(--ring);
      }

      /* sending state: used to visually "disable" the button while we stream */
      .send-btn.sending {
        opacity: 0.6;
        cursor: default;
        pointer-events: none;
      }

      /* small footer note */
      .note {
        font-size: 12px;
        color: var(--muted);
      }
    </style>
  </head>

  <body>
    <main class="wrap" role="main">
      <!-- scrolling list of chat messages -->
      <div class="messages" id="messages" aria-label="conversation log"></div>

      <!-- input row: text input + send button -->
      <div class="search" aria-label="chat input">
        <!-- only a text input now; no attachment button, no emoji modes -->
        <input
          class="input"
          type="text"
          name="message"
          placeholder="type a message"
          aria-label="type a message"
        />

        <!-- circular "send" button on the right -->
        <div
          class="send-btn"
          id="sendBtn"
          role="button"
          aria-label="send message"
          tabindex="0"
        >
          <span class="send-icon">➡️</span>
        </div>
      </div>

      <!-- openai api key input: stored per-conversation server-side -->
      <input
        id="apiKeyInput"
        type="text"
        placeholder="openai api key"
        style="
          width: 100%;
          padding: 6px 10px;
          border-radius: 8px;
          background: #1a1d24;
          border: 1px solid #333;
          color: #e5e7ef;
          font-size: 14px;
        "
      />

      <!-- tiny disclaimer; feel free to change the copy to fit the workshop -->
      <p class="note">
        wired to openai, running on sqlite. local toy, zero guarantees.
      </p>
    </main>

    <script>
      // main ui elements
      const input = document.querySelector(".input");
      const send = document.getElementById("sendBtn");
      const messagesEl = document.getElementById("messages");

      // backend base url for the fastapi server
      const API_BASE = "http://localhost:8000";

      // simple in-memory state
      let conversationId = null; // assigned once by /conversations
      let isSending = false; // lock to avoid multiple parallel sends

      // api key: user provides once, then we hide the input
      let apiKeyLocked = false;
      const apiKeyInput = document.getElementById("apiKeyInput");

      /**
       * append a single chat bubble to the messages panel.
       *
       * msg = {
       *   role: "user" | "assistant" | "system",
       *   text: string
       * }
       *
       * returns: the created DOM element.
       */
      function appendMessageBubble(msg) {
        if (!messagesEl) return null;

        const el = document.createElement("div");
        el.classList.add("message", msg.role || "user");
        el.textContent = msg.text;
        messagesEl.appendChild(el);

        // auto-scroll to bottom so new messages are always visible
        messagesEl.scrollTop = messagesEl.scrollHeight;
        return el;
      }

      /**
       * toggle "sending" state on the send button.
       *
       * when sending:
       *   - add a CSS class for style changes
       *   - mark aria-disabled for accessibility
       */
      function setSending(state) {
        isSending = state;
        if (state) {
          send.classList.add("sending");
          send.setAttribute("aria-disabled", "true");
        } else {
          send.classList.remove("sending");
          send.removeAttribute("aria-disabled");
        }
      }

      /**
       * ensure we have a conversation id from the backend.
       *
       * on first call:
       *   - POST /conversations
       *   - store the returned id
       * on later calls:
       *   - just reuse the cached id
       */
      async function ensureConversation() {
        if (conversationId !== null) return conversationId;

        const res = await fetch(`${API_BASE}/conversations`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: "{}",
        });

        if (!res.ok) {
          console.error("failed to create conversation", res.status);
          throw new Error("conversation create failed");
        }

        const data = await res.json();
        conversationId = data.id;
        console.log("NEW CONVERSATION =>", conversationId);
        return conversationId;
      }

      /**
       * open an SSE connection to stream the assistant response.
       *
       * backend sends Server-Sent Events with these event types:
       *   - "token": individual pieces of the assistant reply text
       *   - "tool": tool call logs (sql queries + results)
       *   - "safety": (optional) verdict from run_safety_check
       *   - "done": indicates the stream is finished
       */
      function streamAssistant(convId) {
        const url = `${API_BASE}/conversations/${convId}/stream`;
        const es = new EventSource(url);

        // buffer for the current assistant message being streamed
        let buffer = "";

        // create an initial placeholder bubble: "awaiting openai..."
        let bubble = appendMessageBubble({
          role: "assistant",
          text: "awaiting openai...",
        });
        if (bubble) bubble.classList.add("pending");

        // handle incremental text tokens from backend
        es.addEventListener("token", (e) => {
          // safety net: if bubble somehow doesn't exist, recreate
          if (!bubble) {
            bubble = appendMessageBubble({
              role: "assistant",
              text: "",
            });
          }

          // first real token: remove pending styling + clear placeholder text
          if (bubble.classList.contains("pending")) {
            bubble.classList.remove("pending");
            bubble.textContent = "";
            buffer = "";
          }

          // append incoming token to buffer and update bubble text
          buffer += e.data;
          bubble.textContent = buffer;

          // keep the scroll pinned to bottom
          messagesEl.scrollTop = messagesEl.scrollHeight;
        });

        // tool events: sql tool usage (query + result payload)
        es.addEventListener("tool", (e) => {
          try {
            const payload = JSON.parse(e.data);
            console.log("[tool event]", payload);
            // this is where you could render a visible "tool log" ui component
          } catch (err) {
            console.error("failed to parse tool event", e.data, err);
          }
        });

        // safety events: verdict from run_safety_check if enabled on backend
        es.addEventListener("safety", (e) => {
          try {
            const verdict = JSON.parse(e.data);
            console.log("[safety event]", verdict);

            const label = verdict.safe ? "SAFE" : "BLOCKED";
            const category = verdict.category || "unknown";
            const reason = verdict.reason || "";

            appendMessageBubble({
              role: "system",
              text: `safety: ${label.toLowerCase()} (${category}) – ${reason}`,
            });
          } catch (err) {
            console.error("failed to parse safety event", e.data, err);
          }
        });

        // done event: server is done streaming, close the connection
        es.addEventListener("done", () => {
          es.close();
          setSending(false);
        });

        // generic sse error handler
        es.onerror = (e) => {
          console.error("sse error", e);
          es.close();
          setSending(false);
        };
      }

      /**
       * send the current input value as a user message.
       *
       * flow:
       *   1) optimistic render of a user bubble
       *   2) ensure conversation id exists
       *   3) POST user message (+ api key) to /messages
       *   4) on success, start streaming assistant response
       */
      async function sendMessage() {
        if (isSending) return;

        const value = input.value.trim();
        if (!value) return;

        // optimistic ui: show the user message immediately
        const userMsg = { role: "user", text: value };
        appendMessageBubble(userMsg);
        input.value = "";

        try {
          setSending(true);
          const convId = await ensureConversation();

          // capture api key from input; hide the field after first use
          const key = apiKeyInput.value.trim();

          if (!apiKeyLocked) {
            apiKeyLocked = true;
            apiKeyInput.style.display = "none";
          }

          // payload matches MessageCreate schema expected by backend
          const payload = {
            role: "user",
            text: value,
            key: key, // stored server-side on the conversation for the workshop
          };

          const res = await fetch(
            `${API_BASE}/conversations/${convId}/messages`,
            {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            }
          );

          if (!res.ok) {
            console.error("failed to send message", res.status);
            setSending(false);
            return;
          }

          // backend accepted the message => start streaming assistant reply
          streamAssistant(convId);
        } catch (err) {
          console.error("sendMessage error:", err);
          setSending(false);
        }
      }

      /**
       * click on the send button triggers sendMessage().
       *
       * note: send button is a <div> with role="button" for styling purposes.
       */
      send.addEventListener("click", () => {
        if (isSending) return;
        void sendMessage();
      });

      /**
       * allow pressing Enter inside the text input to send the message.
       *
       * if you ever want multiline input, this is where you'd gate on shift/meta.
       */
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          if (!isSending) {
            void sendMessage();
          }
        }
      });
    </script>
  </body>
</html>
